<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Electrode Combinations Visualizer</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const App = () => {
      const [dots, setDots] = React.useState([]);
      const [selectedPairs, setSelectedPairs] = React.useState([]);
      const [combinations, setCombinations] = React.useState([]);
      const [hoveredDot, setHoveredDot] = React.useState(null);
      
      // Constants
      const WIDTH = 700;
      const HEIGHT = 700;
      const CENTER_X = WIDTH / 2;
      const CENTER_Y = HEIGHT / 2;
      const RADIUS = 300;
      const DOT_RADIUS = 12;

      // Generate evenly distributed dots
      React.useEffect(() => {
        const newDots = [];
        const totalDots = 20;
        const goldenRatio = (1 + Math.sqrt(5)) / 2;
        
        for (let i = 0; i < totalDots; i++) {
          const theta = 2 * Math.PI * i / goldenRatio;
          const r = RADIUS * 0.9 * Math.sqrt(i / (totalDots - 1));
          const x = CENTER_X + r * Math.cos(theta);
          const y = CENTER_Y + r * Math.sin(theta);
          
          newDots.push({
            id: i + 1,
            name: `E${i + 1}`,
            x,
            y,
          });
        }
        
        setDots(newDots);
      }, []);
      
      // Generate combinations when selected pairs change
      React.useEffect(() => {
        if (selectedPairs.length >= 2) {
          const newCombinations = [];
          
          // Flatten the pairs into a single array of electrodes
          const allElectrodes = selectedPairs.flat();
          
          // Prepare a lookup to know which pair each electrode belongs to
          const pairLookup = {};
          selectedPairs.forEach((pair, pairIndex) => {
            pair.forEach(electrode => {
              pairLookup[electrode.id] = pairIndex;
            });
          });
          
          // Generate all possible valid electrode pairs
          const validPairs = [];
          for (let i = 0; i < allElectrodes.length; i++) {
            for (let j = i + 1; j < allElectrodes.length; j++) {
              const electrode1 = allElectrodes[i];
              const electrode2 = allElectrodes[j];
              
              // Skip if electrodes are from the same original pair/group
              if (pairLookup[electrode1.id] === pairLookup[electrode2.id]) {
                continue;
              }
              
              validPairs.push([electrode1, electrode2]);
            }
          }
          
          // Now generate all combinations of 2 valid pairs
          for (let i = 0; i < validPairs.length; i++) {
            for (let j = i + 1; j < validPairs.length; j++) {
              const pair1 = validPairs[i];
              const pair2 = validPairs[j];
              
              // Check if these pairs share any electrodes
              const usedElectrodes = new Set([
                pair1[0].id, pair1[1].id, pair2[0].id, pair2[1].id
              ]);
              
              // If there are 4 distinct electrodes, this is a valid combination
              if (usedElectrodes.size === 4) {
                newCombinations.push([pair1, pair2]);
              }
            }
          }
          
          setCombinations(newCombinations);
        } else {
          setCombinations([]);
        }
      }, [selectedPairs]);
      
      // Handle dot click to select pairs
      const handleDotClick = (dot) => {
        if (hoveredDot === null) {
          setHoveredDot(dot);
        } else {
          if (hoveredDot.id !== dot.id) {
            // Create a pair
            const newPair = [hoveredDot, dot];
            
            // Check if we already have 4 pairs
            if (selectedPairs.length < 4) {
              setSelectedPairs([...selectedPairs, newPair]);
            } else {
              // Replace the first pair (rotate)
              const updatedPairs = [...selectedPairs.slice(1), newPair];
              setSelectedPairs(updatedPairs);
            }
          }
          setHoveredDot(null);
        }
      };
      
      // Reset all selections
      const handleReset = () => {
        setSelectedPairs([]);
        setHoveredDot(null);
        setCombinations([]);
      };
      
      // Get color for dot based on status and pair
      const getDotColor = (dot) => {
        if (hoveredDot && hoveredDot.id === dot.id) {
          return '#ff7700'; // Highlighted dot
        }
        
        // Check if dot is part of any selected pair and return that pair's color
        for (let i = 0; i < selectedPairs.length; i++) {
          const pair = selectedPairs[i];
          if (pair[0].id === dot.id || pair[1].id === dot.id) {
            return getPairColor(i); // Each group has its own color
          }
        }
        
        return '#555555'; // Default color
      };
      
      // Get color for pair connection line
      const getPairColor = (index) => {
        const colors = ['#ff3333', '#33cc33', '#3366ff', '#ffcc00'];
        return colors[index % colors.length];
      };
      
      return (
        <div style={{margin: '20px'}}>
          <h2 style={{textAlign: 'center'}}>Electrode Combination Visualizer</h2>
          
          <div style={{textAlign: 'center', marginBottom: '15px'}}>
            <button 
              style={{padding: '8px 16px', backgroundColor: '#ef4444', color: 'white', border: 'none', borderRadius: '4px', marginRight: '10px'}}
              onClick={handleReset}
            >
              Reset
            </button>
            <span>
              {hoveredDot ? `Select second electrode to pair with ${hoveredDot.name}` : 'Select first electrode of a pair'}
            </span>
          </div>
          
          <div style={{marginBottom: '15px'}}>
            <div style={{fontWeight: 'bold'}}>Selected Pairs:</div>
            <div style={{display: 'flex', flexWrap: 'wrap', gap: '10px'}}>
              {selectedPairs.map((pair, index) => (
                <div 
                  key={index} 
                  style={{padding: '5px 10px', borderRadius: '4px', backgroundColor: `${getPairColor(index)}44`}}
                >
                  {pair[0].name} & {pair[1].name}
                </div>
              ))}
            </div>
          </div>
          
          <div style={{display: 'flex', alignItems: 'flex-start', gap: '20px'}}>
            <svg width={WIDTH} height={HEIGHT} style={{border: '1px solid #d1d5db', borderRadius: '4px', backgroundColor: '#f8f9fa'}}>
              {/* Outer circle */}
              <circle 
                cx={CENTER_X} 
                cy={CENTER_Y} 
                r={RADIUS} 
                fill="none" 
                stroke="#333" 
                strokeWidth="2" 
              />
              
              {/* Connection lines for selected pairs */}
              {selectedPairs.map((pair, index) => (
                <line 
                  key={`pair-${index}`}
                  x1={pair[0].x}
                  y1={pair[0].y}
                  x2={pair[1].x}
                  y2={pair[1].y}
                  stroke={getPairColor(index)}
                  strokeWidth="2"
                />
              ))}
              
              {/* Lines for all combinations */}
              {combinations.map((comb, index) => (
                <g key={`comb-${index}`}>
                  {/* First pair */}
                  <line 
                    x1={comb[0][0].x}
                    y1={comb[0][0].y}
                    x2={comb[0][1].x}
                    y2={comb[0][1].y}
                    stroke="#555555"
                    strokeWidth="1.5"
                    strokeDasharray="3,3"
                  />
                  {/* Second pair */}
                  <line 
                    x1={comb[1][0].x}
                    y1={comb[1][0].y}
                    x2={comb[1][1].x}
                    y2={comb[1][1].y}
                    stroke="#555555"
                    strokeWidth="1.5"
                    strokeDasharray="3,3"
                  />
                </g>
              ))}
              
              {/* Dots */}
              {dots.map((dot) => (
                <g key={dot.id} onClick={() => handleDotClick(dot)}>
                  <circle 
                    cx={dot.x} 
                    cy={dot.y} 
                    r={DOT_RADIUS} 
                    fill={getDotColor(dot)} 
                    stroke="#000"
                    strokeWidth="1"
                    style={{cursor: 'pointer'}}
                  />
                  <text 
                    x={dot.x} 
                    y={dot.y} 
                    textAnchor="middle" 
                    dominantBaseline="middle" 
                    fontSize="10"
                    fill="#fff"
                    style={{pointerEvents: 'none'}}
                  >
                    {dot.name}
                  </text>
                </g>
              ))}
            </svg>
            
            {combinations.length > 0 && (
              <div style={{
                flex: '1', 
                padding: '15px', 
                borderRadius: '4px', 
                border: '1px solid #d1d5db',
                backgroundColor: 'white',
                height: HEIGHT + 'px',
                overflowY: 'auto'
              }}>
                <div style={{fontWeight: 'bold', marginBottom: '10px', fontSize: '18px'}}>
                  Combinations ({combinations.length}):
                </div>
                <div style={{display: 'flex', flexDirection: 'column', gap: '5px'}}>
                  {combinations.map((comb, index) => (
                    <div key={index} style={{
                      padding: '8px 10px', 
                      borderRadius: '4px', 
                      backgroundColor: '#f5f5f5',
                      fontSize: '14px',
                      fontFamily: 'monospace'
                    }}>
                      ({comb[0][0].name}-{comb[0][1].name}) + ({comb[1][0].name}-{comb[1][1].name})
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
          
          <div style={{marginTop: '15px', fontSize: '14px'}}>
            <p>Instructions:</p>
            <ol style={{paddingLeft: '25px'}}>
              <li>Click on two dots to create a pair</li>
              <li>Create up to 4 pairs</li>
              <li>All possible combinations between pairs will be generated</li>
              <li>Use the reset button to start over</li>
            </ol>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
